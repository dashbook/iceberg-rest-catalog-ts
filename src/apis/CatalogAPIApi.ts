/* tslint:disable */
/* eslint-disable */
/**
 * Apache Iceberg REST Catalog API
 * Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CommitTableRequest,
  CommitTableResponse,
  CommitTransactionRequest,
  CommitViewRequest,
  CreateNamespaceRequest,
  CreateNamespaceResponse,
  CreateTableRequest,
  CreateViewRequest,
  ErrorModel,
  FetchPlanningResult,
  FetchScanTasksRequest,
  FetchScanTasksResult,
  GetNamespaceResponse,
  IcebergErrorResponse,
  ListNamespacesResponse,
  ListTablesResponse,
  LoadCredentialsResponse,
  LoadTableResult,
  LoadViewResult,
  PlanTableScanRequest,
  PlanTableScanResult,
  RegisterTableRequest,
  RenameTableRequest,
  ReportMetricsRequest,
  UpdateNamespacePropertiesRequest,
  UpdateNamespacePropertiesResponse,
} from '../models/index';
import {
    CommitTableRequestFromJSON,
    CommitTableRequestToJSON,
    CommitTableResponseFromJSON,
    CommitTableResponseToJSON,
    CommitTransactionRequestFromJSON,
    CommitTransactionRequestToJSON,
    CommitViewRequestFromJSON,
    CommitViewRequestToJSON,
    CreateNamespaceRequestFromJSON,
    CreateNamespaceRequestToJSON,
    CreateNamespaceResponseFromJSON,
    CreateNamespaceResponseToJSON,
    CreateTableRequestFromJSON,
    CreateTableRequestToJSON,
    CreateViewRequestFromJSON,
    CreateViewRequestToJSON,
    ErrorModelFromJSON,
    ErrorModelToJSON,
    FetchPlanningResultFromJSON,
    FetchPlanningResultToJSON,
    FetchScanTasksRequestFromJSON,
    FetchScanTasksRequestToJSON,
    FetchScanTasksResultFromJSON,
    FetchScanTasksResultToJSON,
    GetNamespaceResponseFromJSON,
    GetNamespaceResponseToJSON,
    IcebergErrorResponseFromJSON,
    IcebergErrorResponseToJSON,
    ListNamespacesResponseFromJSON,
    ListNamespacesResponseToJSON,
    ListTablesResponseFromJSON,
    ListTablesResponseToJSON,
    LoadCredentialsResponseFromJSON,
    LoadCredentialsResponseToJSON,
    LoadTableResultFromJSON,
    LoadTableResultToJSON,
    LoadViewResultFromJSON,
    LoadViewResultToJSON,
    PlanTableScanRequestFromJSON,
    PlanTableScanRequestToJSON,
    PlanTableScanResultFromJSON,
    PlanTableScanResultToJSON,
    RegisterTableRequestFromJSON,
    RegisterTableRequestToJSON,
    RenameTableRequestFromJSON,
    RenameTableRequestToJSON,
    ReportMetricsRequestFromJSON,
    ReportMetricsRequestToJSON,
    UpdateNamespacePropertiesRequestFromJSON,
    UpdateNamespacePropertiesRequestToJSON,
    UpdateNamespacePropertiesResponseFromJSON,
    UpdateNamespacePropertiesResponseToJSON,
} from '../models/index';

export interface CancelPlanningRequest {
    prefix: string;
    namespace: string;
    table: string;
    planId: string;
}

export interface CommitTransactionOperationRequest {
    prefix: string;
    commitTransactionRequest: CommitTransactionRequest;
}

export interface CreateNamespaceOperationRequest {
    prefix: string;
    createNamespaceRequest: CreateNamespaceRequest;
}

export interface CreateTableOperationRequest {
    prefix: string;
    namespace: string;
    createTableRequest: CreateTableRequest;
    // xIcebergAccessDelegation?: CreateTableXIcebergAccessDelegationEnum;
}

export interface CreateViewOperationRequest {
    prefix: string;
    namespace: string;
    createViewRequest: CreateViewRequest;
}

export interface DropNamespaceRequest {
    prefix: string;
    namespace: string;
}

export interface DropTableRequest {
    prefix: string;
    namespace: string;
    table: string;
    purgeRequested?: boolean;
}

export interface DropViewRequest {
    prefix: string;
    namespace: string;
    view: string;
}

export interface FetchPlanningResultRequest {
    prefix: string;
    namespace: string;
    table: string;
    planId: string;
}

export interface FetchScanTasksOperationRequest {
    prefix: string;
    namespace: string;
    table: string;
    fetchScanTasksRequest?: FetchScanTasksRequest;
}

export interface ListNamespacesRequest {
    prefix: string;
    pageToken?: string;
    pageSize?: number;
    parent?: string;
}

export interface ListTablesRequest {
    prefix: string;
    namespace: string;
    pageToken?: string;
    pageSize?: number;
}

export interface ListViewsRequest {
    prefix: string;
    namespace: string;
    pageToken?: string;
    pageSize?: number;
}

export interface LoadCredentialsRequest {
    prefix: string;
    namespace: string;
    table: string;
}

export interface LoadNamespaceMetadataRequest {
    prefix: string;
    namespace: string;
}

export interface LoadTableRequest {
    prefix: string;
    namespace: string;
    table: string;
    xIcebergAccessDelegation?: LoadTableXIcebergAccessDelegationEnum;
    ifNoneMatch?: string;
    snapshots?: LoadTableSnapshotsEnum;
}

export interface LoadViewRequest {
    prefix: string;
    namespace: string;
    view: string;
}

export interface NamespaceExistsRequest {
    prefix: string;
    namespace: string;
}

export interface PlanTableScanOperationRequest {
    prefix: string;
    namespace: string;
    table: string;
    planTableScanRequest?: PlanTableScanRequest;
}

export interface RegisterTableOperationRequest {
    prefix: string;
    namespace: string;
    registerTableRequest: RegisterTableRequest;
}

export interface RenameTableOperationRequest {
    prefix: string;
    renameTableRequest: RenameTableRequest;
}

export interface RenameViewRequest {
    prefix: string;
    renameTableRequest: RenameTableRequest;
}

export interface ReplaceViewRequest {
    prefix: string;
    namespace: string;
    view: string;
    commitViewRequest: CommitViewRequest;
}

export interface ReportMetricsOperationRequest {
    prefix: string;
    namespace: string;
    table: string;
    reportMetricsRequest: ReportMetricsRequest;
}

export interface TableExistsRequest {
    prefix: string;
    namespace: string;
    table: string;
}

export interface UpdatePropertiesRequest {
    prefix: string;
    namespace: string;
    updateNamespacePropertiesRequest: UpdateNamespacePropertiesRequest;
}

export interface UpdateTableRequest {
    prefix: string;
    namespace: string;
    table: string;
    commitTableRequest: CommitTableRequest;
}

export interface ViewExistsRequest {
    prefix: string;
    namespace: string;
    view: string;
}

/**
 * 
 */
export class CatalogAPIApi extends runtime.BaseAPI {

    /**
     * Cancels scan planning for a plan-id.  This notifies the service that it can release resources held for the scan. Clients should cancel scans that are no longer needed, either while the plan-id returns a \"submitted\" status or while there are remaining plan tasks that have not been fetched.  Cancellation is not necessary when - Scan tasks for each plan task have been fetched using fetchScanTasks - A plan-id has produced a \"failed\" or \"cancelled\" status from   planTableScan or fetchPlanningResult 
     * Cancels scan planning for a plan-id
     */
    async cancelPlanningRaw(requestParameters: CancelPlanningRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling cancelPlanning().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling cancelPlanning().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling cancelPlanning().'
            );
        }

        if (requestParameters['planId'] == null) {
            throw new runtime.RequiredError(
                'planId',
                'Required parameter "planId" was null or undefined when calling cancelPlanning().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan/{plan-id}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))).replace(`{${"plan-id"}}`, encodeURIComponent(String(requestParameters['planId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancels scan planning for a plan-id.  This notifies the service that it can release resources held for the scan. Clients should cancel scans that are no longer needed, either while the plan-id returns a \"submitted\" status or while there are remaining plan tasks that have not been fetched.  Cancellation is not necessary when - Scan tasks for each plan task have been fetched using fetchScanTasks - A plan-id has produced a \"failed\" or \"cancelled\" status from   planTableScan or fetchPlanningResult 
     * Cancels scan planning for a plan-id
     */
    async cancelPlanning(requestParameters: CancelPlanningRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelPlanningRaw(requestParameters, initOverrides);
    }

    /**
     * Commit updates to multiple tables in an atomic operation
     */
    async commitTransactionRaw(requestParameters: CommitTransactionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling commitTransaction().'
            );
        }

        if (requestParameters['commitTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'commitTransactionRequest',
                'Required parameter "commitTransactionRequest" was null or undefined when calling commitTransaction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/transactions/commit`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommitTransactionRequestToJSON(requestParameters['commitTransactionRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Commit updates to multiple tables in an atomic operation
     */
    async commitTransaction(requestParameters: CommitTransactionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.commitTransactionRaw(requestParameters, initOverrides);
    }

    /**
     * Create a namespace, with an optional set of properties. The server might also add properties, such as `last_modified_time` etc.
     * Create a namespace
     */
    async createNamespaceRaw(requestParameters: CreateNamespaceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateNamespaceResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling createNamespace().'
            );
        }

        if (requestParameters['createNamespaceRequest'] == null) {
            throw new runtime.RequiredError(
                'createNamespaceRequest',
                'Required parameter "createNamespaceRequest" was null or undefined when calling createNamespace().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateNamespaceRequestToJSON(requestParameters['createNamespaceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateNamespaceResponseFromJSON(jsonValue));
    }

    /**
     * Create a namespace, with an optional set of properties. The server might also add properties, such as `last_modified_time` etc.
     * Create a namespace
     */
    async createNamespace(requestParameters: CreateNamespaceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateNamespaceResponse> {
        const response = await this.createNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a table or start a create transaction, like atomic CTAS.  If `stage-create` is false, the table is created immediately.  If `stage-create` is true, the table is not created, but table metadata is initialized and returned. The service should prepare as needed for a commit to the table commit endpoint to complete the create transaction. The client uses the returned metadata to begin a transaction. To commit the transaction, the client sends all create and subsequent changes to the table commit route. Changes from the table create operation include changes like AddSchemaUpdate and SetCurrentSchemaUpdate that set the initial table state.
     * Create a table in the given namespace
     */
    async createTableRaw(requestParameters: CreateTableOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadTableResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling createTable().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createTable().'
            );
        }

        if (requestParameters['createTableRequest'] == null) {
            throw new runtime.RequiredError(
                'createTableRequest',
                'Required parameter "createTableRequest" was null or undefined when calling createTable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xIcebergAccessDelegation'] != null) {
            headerParameters['X-Iceberg-Access-Delegation'] = String(requestParameters['xIcebergAccessDelegation']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTableRequestToJSON(requestParameters['createTableRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadTableResultFromJSON(jsonValue));
    }

    /**
     * Create a table or start a create transaction, like atomic CTAS.  If `stage-create` is false, the table is created immediately.  If `stage-create` is true, the table is not created, but table metadata is initialized and returned. The service should prepare as needed for a commit to the table commit endpoint to complete the create transaction. The client uses the returned metadata to begin a transaction. To commit the transaction, the client sends all create and subsequent changes to the table commit route. Changes from the table create operation include changes like AddSchemaUpdate and SetCurrentSchemaUpdate that set the initial table state.
     * Create a table in the given namespace
     */
    async createTable(requestParameters: CreateTableOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadTableResult> {
        const response = await this.createTableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a view in the given namespace.
     * Create a view in the given namespace
     */
    async createViewRaw(requestParameters: CreateViewOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadViewResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling createView().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createView().'
            );
        }

        if (requestParameters['createViewRequest'] == null) {
            throw new runtime.RequiredError(
                'createViewRequest',
                'Required parameter "createViewRequest" was null or undefined when calling createView().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/views`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateViewRequestToJSON(requestParameters['createViewRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadViewResultFromJSON(jsonValue));
    }

    /**
     * Create a view in the given namespace.
     * Create a view in the given namespace
     */
    async createView(requestParameters: CreateViewOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadViewResult> {
        const response = await this.createViewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Drop a namespace from the catalog. Namespace must be empty.
     */
    async dropNamespaceRaw(requestParameters: DropNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling dropNamespace().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling dropNamespace().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Drop a namespace from the catalog. Namespace must be empty.
     */
    async dropNamespace(requestParameters: DropNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dropNamespaceRaw(requestParameters, initOverrides);
    }

    /**
     * Remove a table from the catalog
     * Drop a table from the catalog
     */
    async dropTableRaw(requestParameters: DropTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling dropTable().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling dropTable().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling dropTable().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['purgeRequested'] != null) {
            queryParameters['purgeRequested'] = requestParameters['purgeRequested'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a table from the catalog
     * Drop a table from the catalog
     */
    async dropTable(requestParameters: DropTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dropTableRaw(requestParameters, initOverrides);
    }

    /**
     * Remove a view from the catalog
     * Drop a view from the catalog
     */
    async dropViewRaw(requestParameters: DropViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling dropView().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling dropView().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling dropView().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/views/{view}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a view from the catalog
     * Drop a view from the catalog
     */
    async dropView(requestParameters: DropViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dropViewRaw(requestParameters, initOverrides);
    }

    /**
     * Fetches the result of scan planning for a plan-id.  Responses must include a valid status - When \"completed\" the planning operation has produced plan-tasks and   file-scan-tasks that must be returned in the response  - When \"submitted\" the planning operation has not completed; the client   should wait to call this endpoint again to fetch a completed response  - When \"failed\" the response must be a valid error response - When \"cancelled\" the plan-id is invalid and should be discarded  The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status. 
     * Fetches the result of scan planning for a plan-id
     */
    async fetchPlanningResultRaw(requestParameters: FetchPlanningResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchPlanningResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling fetchPlanningResult().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling fetchPlanningResult().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling fetchPlanningResult().'
            );
        }

        if (requestParameters['planId'] == null) {
            throw new runtime.RequiredError(
                'planId',
                'Required parameter "planId" was null or undefined when calling fetchPlanningResult().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan/{plan-id}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))).replace(`{${"plan-id"}}`, encodeURIComponent(String(requestParameters['planId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchPlanningResultFromJSON(jsonValue));
    }

    /**
     * Fetches the result of scan planning for a plan-id.  Responses must include a valid status - When \"completed\" the planning operation has produced plan-tasks and   file-scan-tasks that must be returned in the response  - When \"submitted\" the planning operation has not completed; the client   should wait to call this endpoint again to fetch a completed response  - When \"failed\" the response must be a valid error response - When \"cancelled\" the plan-id is invalid and should be discarded  The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status. 
     * Fetches the result of scan planning for a plan-id
     */
    async fetchPlanningResult(requestParameters: FetchPlanningResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchPlanningResult> {
        const response = await this.fetchPlanningResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches result tasks for a plan task.
     * Fetches result tasks for a plan task
     */
    async fetchScanTasksRaw(requestParameters: FetchScanTasksOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchScanTasksResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling fetchScanTasks().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling fetchScanTasks().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling fetchScanTasks().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}/tasks`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchScanTasksRequestToJSON(requestParameters['fetchScanTasksRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchScanTasksResultFromJSON(jsonValue));
    }

    /**
     * Fetches result tasks for a plan task.
     * Fetches result tasks for a plan task
     */
    async fetchScanTasks(requestParameters: FetchScanTasksOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchScanTasksResult> {
        const response = await this.fetchScanTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all namespaces at a certain level, optionally starting from a given parent namespace. If table accounting.tax.paid.info exists, using \'SELECT NAMESPACE IN accounting\' would translate into `GET /namespaces?parent=accounting` and must return a namespace, [\"accounting\", \"tax\"] only. Using \'SELECT NAMESPACE IN accounting.tax\' would translate into `GET /namespaces?parent=accounting%1Ftax` and must return a namespace, [\"accounting\", \"tax\", \"paid\"]. If `parent` is not provided, all top-level namespaces should be listed.
     * List namespaces, optionally providing a parent namespace to list underneath
     */
    async listNamespacesRaw(requestParameters: ListNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListNamespacesResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling listNamespaces().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageToken'] != null) {
            queryParameters['pageToken'] = requestParameters['pageToken'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['parent'] != null) {
            queryParameters['parent'] = requestParameters['parent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListNamespacesResponseFromJSON(jsonValue));
    }

    /**
     * List all namespaces at a certain level, optionally starting from a given parent namespace. If table accounting.tax.paid.info exists, using \'SELECT NAMESPACE IN accounting\' would translate into `GET /namespaces?parent=accounting` and must return a namespace, [\"accounting\", \"tax\"] only. Using \'SELECT NAMESPACE IN accounting.tax\' would translate into `GET /namespaces?parent=accounting%1Ftax` and must return a namespace, [\"accounting\", \"tax\", \"paid\"]. If `parent` is not provided, all top-level namespaces should be listed.
     * List namespaces, optionally providing a parent namespace to list underneath
     */
    async listNamespaces(requestParameters: ListNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListNamespacesResponse> {
        const response = await this.listNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all table identifiers under this namespace
     * List all table identifiers underneath a given namespace
     */
    async listTablesRaw(requestParameters: ListTablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTablesResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling listTables().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listTables().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageToken'] != null) {
            queryParameters['pageToken'] = requestParameters['pageToken'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTablesResponseFromJSON(jsonValue));
    }

    /**
     * Return all table identifiers under this namespace
     * List all table identifiers underneath a given namespace
     */
    async listTables(requestParameters: ListTablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTablesResponse> {
        const response = await this.listTablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all view identifiers under this namespace
     * List all view identifiers underneath a given namespace
     */
    async listViewsRaw(requestParameters: ListViewsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTablesResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling listViews().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listViews().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageToken'] != null) {
            queryParameters['pageToken'] = requestParameters['pageToken'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/views`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTablesResponseFromJSON(jsonValue));
    }

    /**
     * Return all view identifiers under this namespace
     * List all view identifiers underneath a given namespace
     */
    async listViews(requestParameters: ListViewsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTablesResponse> {
        const response = await this.listViewsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load vended credentials for a table from the catalog.
     * Load vended credentials for a table from the catalog
     */
    async loadCredentialsRaw(requestParameters: LoadCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadCredentialsResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling loadCredentials().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling loadCredentials().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling loadCredentials().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}/credentials`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadCredentialsResponseFromJSON(jsonValue));
    }

    /**
     * Load vended credentials for a table from the catalog.
     * Load vended credentials for a table from the catalog
     */
    async loadCredentials(requestParameters: LoadCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadCredentialsResponse> {
        const response = await this.loadCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all stored metadata properties for a given namespace
     * Load the metadata properties for a namespace
     */
    async loadNamespaceMetadataRaw(requestParameters: LoadNamespaceMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNamespaceResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling loadNamespaceMetadata().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling loadNamespaceMetadata().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNamespaceResponseFromJSON(jsonValue));
    }

    /**
     * Return all stored metadata properties for a given namespace
     * Load the metadata properties for a namespace
     */
    async loadNamespaceMetadata(requestParameters: LoadNamespaceMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNamespaceResponse> {
        const response = await this.loadNamespaceMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load a table from the catalog.  The response contains both configuration and table metadata. The configuration, if non-empty is used as additional configuration for the table that overrides catalog configuration. For example, this configuration may change the FileIO implementation to be used for the table.  The response also contains the table\'s full metadata, matching the table metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the table. The configuration key \"token\" is used to pass an access token to be used as a bearer token for table requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
     * Load a table from the catalog
     */
    async loadTableRaw(requestParameters: LoadTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadTableResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling loadTable().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling loadTable().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling loadTable().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['snapshots'] != null) {
            queryParameters['snapshots'] = requestParameters['snapshots'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xIcebergAccessDelegation'] != null) {
            headerParameters['X-Iceberg-Access-Delegation'] = String(requestParameters['xIcebergAccessDelegation']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = String(requestParameters['ifNoneMatch']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadTableResultFromJSON(jsonValue));
    }

    /**
     * Load a table from the catalog.  The response contains both configuration and table metadata. The configuration, if non-empty is used as additional configuration for the table that overrides catalog configuration. For example, this configuration may change the FileIO implementation to be used for the table.  The response also contains the table\'s full metadata, matching the table metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the table. The configuration key \"token\" is used to pass an access token to be used as a bearer token for table requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
     * Load a table from the catalog
     */
    async loadTable(requestParameters: LoadTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadTableResult> {
        const response = await this.loadTableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load a view from the catalog.  The response contains both configuration and view metadata. The configuration, if non-empty is used as additional configuration for the view that overrides catalog configuration.  The response also contains the view\'s full metadata, matching the view metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the view. The configuration key \"token\" is used to pass an access token to be used as a bearer token for view requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
     * Load a view from the catalog
     */
    async loadViewRaw(requestParameters: LoadViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadViewResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling loadView().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling loadView().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling loadView().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/views/{view}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadViewResultFromJSON(jsonValue));
    }

    /**
     * Load a view from the catalog.  The response contains both configuration and view metadata. The configuration, if non-empty is used as additional configuration for the view that overrides catalog configuration.  The response also contains the view\'s full metadata, matching the view metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the view. The configuration key \"token\" is used to pass an access token to be used as a bearer token for view requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
     * Load a view from the catalog
     */
    async loadView(requestParameters: LoadViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadViewResult> {
        const response = await this.loadViewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if a namespace exists. The response does not contain a body.
     * Check if a namespace exists
     */
    async namespaceExistsRaw(requestParameters: NamespaceExistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling namespaceExists().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling namespaceExists().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check if a namespace exists. The response does not contain a body.
     * Check if a namespace exists
     */
    async namespaceExists(requestParameters: NamespaceExistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.namespaceExistsRaw(requestParameters, initOverrides);
    }

    /**
     * Submits a scan for server-side planning.  Point-in-time scans are planned by passing snapshot-id to identify the table snapshot to scan. Incremental scans are planned by passing both start-snapshot-id and end-snapshot-id. Requests that include both point in time config properties and incremental config properties are invalid. If the request does not include either incremental or point-in-time config properties, scan planning should produce a point-in-time scan of the latest snapshot in the table\'s main branch.  Responses must include a valid status listed below. A \"cancelled\" status is considered invalid for this endpoint.   - When \"completed\" the planning operation has produced plan tasks and   file scan tasks that must be returned in the response (not fetched   later by calling fetchPlanningResult)  - When \"submitted\" the response must include a plan-id used to poll   fetchPlanningResult to fetch the planning result when it is ready  - When \"failed\" the response must be a valid error response The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status.  Responses that include a plan-id indicate that the service is holding state or performing work for the client.  - Clients should use the plan-id to fetch results from   fetchPlanningResult when the response status is \"submitted\"  - Clients should inform the service if planning results are no longer   needed by calling cancelPlanning. Cancellation is not necessary after   fetchScanTasks has been used to fetch scan tasks for each plan task. 
     * Submit a scan for planning
     */
    async planTableScanRaw(requestParameters: PlanTableScanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlanTableScanResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling planTableScan().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling planTableScan().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling planTableScan().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlanTableScanRequestToJSON(requestParameters['planTableScanRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlanTableScanResultFromJSON(jsonValue));
    }

    /**
     * Submits a scan for server-side planning.  Point-in-time scans are planned by passing snapshot-id to identify the table snapshot to scan. Incremental scans are planned by passing both start-snapshot-id and end-snapshot-id. Requests that include both point in time config properties and incremental config properties are invalid. If the request does not include either incremental or point-in-time config properties, scan planning should produce a point-in-time scan of the latest snapshot in the table\'s main branch.  Responses must include a valid status listed below. A \"cancelled\" status is considered invalid for this endpoint.   - When \"completed\" the planning operation has produced plan tasks and   file scan tasks that must be returned in the response (not fetched   later by calling fetchPlanningResult)  - When \"submitted\" the response must include a plan-id used to poll   fetchPlanningResult to fetch the planning result when it is ready  - When \"failed\" the response must be a valid error response The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status.  Responses that include a plan-id indicate that the service is holding state or performing work for the client.  - Clients should use the plan-id to fetch results from   fetchPlanningResult when the response status is \"submitted\"  - Clients should inform the service if planning results are no longer   needed by calling cancelPlanning. Cancellation is not necessary after   fetchScanTasks has been used to fetch scan tasks for each plan task. 
     * Submit a scan for planning
     */
    async planTableScan(requestParameters: PlanTableScanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlanTableScanResult> {
        const response = await this.planTableScanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a table using given metadata file location.
     * Register a table in the given namespace using given metadata file location
     */
    async registerTableRaw(requestParameters: RegisterTableOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadTableResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling registerTable().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling registerTable().'
            );
        }

        if (requestParameters['registerTableRequest'] == null) {
            throw new runtime.RequiredError(
                'registerTableRequest',
                'Required parameter "registerTableRequest" was null or undefined when calling registerTable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/register`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterTableRequestToJSON(requestParameters['registerTableRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadTableResultFromJSON(jsonValue));
    }

    /**
     * Register a table using given metadata file location.
     * Register a table in the given namespace using given metadata file location
     */
    async registerTable(requestParameters: RegisterTableOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadTableResult> {
        const response = await this.registerTableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Rename a table from one identifier to another. It\'s valid to move a table across namespaces, but the server implementation is not required to support it.
     * Rename a table from its current name to a new name
     */
    async renameTableRaw(requestParameters: RenameTableOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling renameTable().'
            );
        }

        if (requestParameters['renameTableRequest'] == null) {
            throw new runtime.RequiredError(
                'renameTableRequest',
                'Required parameter "renameTableRequest" was null or undefined when calling renameTable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/tables/rename`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RenameTableRequestToJSON(requestParameters['renameTableRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Rename a table from one identifier to another. It\'s valid to move a table across namespaces, but the server implementation is not required to support it.
     * Rename a table from its current name to a new name
     */
    async renameTable(requestParameters: RenameTableOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.renameTableRaw(requestParameters, initOverrides);
    }

    /**
     * Rename a view from one identifier to another. It\'s valid to move a view across namespaces, but the server implementation is not required to support it.
     * Rename a view from its current name to a new name
     */
    async renameViewRaw(requestParameters: RenameViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling renameView().'
            );
        }

        if (requestParameters['renameTableRequest'] == null) {
            throw new runtime.RequiredError(
                'renameTableRequest',
                'Required parameter "renameTableRequest" was null or undefined when calling renameView().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/views/rename`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RenameTableRequestToJSON(requestParameters['renameTableRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Rename a view from one identifier to another. It\'s valid to move a view across namespaces, but the server implementation is not required to support it.
     * Rename a view from its current name to a new name
     */
    async renameView(requestParameters: RenameViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.renameViewRaw(requestParameters, initOverrides);
    }

    /**
     * Commit updates to a view.
     * Replace a view
     */
    async replaceViewRaw(requestParameters: ReplaceViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoadViewResult>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling replaceView().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceView().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling replaceView().'
            );
        }

        if (requestParameters['commitViewRequest'] == null) {
            throw new runtime.RequiredError(
                'commitViewRequest',
                'Required parameter "commitViewRequest" was null or undefined when calling replaceView().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/views/{view}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommitViewRequestToJSON(requestParameters['commitViewRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoadViewResultFromJSON(jsonValue));
    }

    /**
     * Commit updates to a view.
     * Replace a view
     */
    async replaceView(requestParameters: ReplaceViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoadViewResult> {
        const response = await this.replaceViewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send a metrics report to this endpoint to be processed by the backend
     */
    async reportMetricsRaw(requestParameters: ReportMetricsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling reportMetrics().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling reportMetrics().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling reportMetrics().'
            );
        }

        if (requestParameters['reportMetricsRequest'] == null) {
            throw new runtime.RequiredError(
                'reportMetricsRequest',
                'Required parameter "reportMetricsRequest" was null or undefined when calling reportMetrics().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReportMetricsRequestToJSON(requestParameters['reportMetricsRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Send a metrics report to this endpoint to be processed by the backend
     */
    async reportMetrics(requestParameters: ReportMetricsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reportMetricsRaw(requestParameters, initOverrides);
    }

    /**
     * Check if a table exists within a given namespace. The response does not contain a body.
     * Check if a table exists
     */
    async tableExistsRaw(requestParameters: TableExistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling tableExists().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling tableExists().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling tableExists().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check if a table exists within a given namespace. The response does not contain a body.
     * Check if a table exists
     */
    async tableExists(requestParameters: TableExistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.tableExistsRaw(requestParameters, initOverrides);
    }

    /**
     * Set and/or remove properties on a namespace. The request body specifies a list of properties to remove and a map of key value pairs to update. Properties that are not in the request are not modified or removed by this call. Server implementations are not required to support namespace properties.
     * Set or remove properties on a namespace
     */
    async updatePropertiesRaw(requestParameters: UpdatePropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateNamespacePropertiesResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling updateProperties().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling updateProperties().'
            );
        }

        if (requestParameters['updateNamespacePropertiesRequest'] == null) {
            throw new runtime.RequiredError(
                'updateNamespacePropertiesRequest',
                'Required parameter "updateNamespacePropertiesRequest" was null or undefined when calling updateProperties().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/properties`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateNamespacePropertiesRequestToJSON(requestParameters['updateNamespacePropertiesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateNamespacePropertiesResponseFromJSON(jsonValue));
    }

    /**
     * Set and/or remove properties on a namespace. The request body specifies a list of properties to remove and a map of key value pairs to update. Properties that are not in the request are not modified or removed by this call. Server implementations are not required to support namespace properties.
     * Set or remove properties on a namespace
     */
    async updateProperties(requestParameters: UpdatePropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateNamespacePropertiesResponse> {
        const response = await this.updatePropertiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Commit updates to a table.  Commits have two parts, requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref\'s snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.  Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.  Create table transactions that are started by createTable with `stage-create` set to true are committed using this route. Transactions should include all changes to the table, including table initialization, like AddSchemaUpdate and SetCurrentSchemaUpdate. The `assert-create` requirement is used to ensure that the table was not created concurrently.
     * Commit updates to a table
     */
    async updateTableRaw(requestParameters: UpdateTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitTableResponse>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling updateTable().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling updateTable().'
            );
        }

        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling updateTable().'
            );
        }

        if (requestParameters['commitTableRequest'] == null) {
            throw new runtime.RequiredError(
                'commitTableRequest',
                'Required parameter "commitTableRequest" was null or undefined when calling updateTable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/tables/{table}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommitTableRequestToJSON(requestParameters['commitTableRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitTableResponseFromJSON(jsonValue));
    }

    /**
     * Commit updates to a table.  Commits have two parts, requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref\'s snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.  Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.  Create table transactions that are started by createTable with `stage-create` set to true are committed using this route. Transactions should include all changes to the table, including table initialization, like AddSchemaUpdate and SetCurrentSchemaUpdate. The `assert-create` requirement is used to ensure that the table was not created concurrently.
     * Commit updates to a table
     */
    async updateTable(requestParameters: UpdateTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitTableResponse> {
        const response = await this.updateTableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if a view exists within a given namespace. This request does not return a response body.
     * Check if a view exists
     */
    async viewExistsRaw(requestParameters: ViewExistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling viewExists().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling viewExists().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling viewExists().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["catalog"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/{prefix}/namespaces/{namespace}/views/{view}`.replace(`{${"prefix"}}`, encodeURIComponent(String(requestParameters['prefix']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check if a view exists within a given namespace. This request does not return a response body.
     * Check if a view exists
     */
    async viewExists(requestParameters: ViewExistsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.viewExistsRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const CreateTableOperationXIcebergAccessDelegationEnum = {
    VendedCredentials: 'vended-credentials',
    RemoteSigning: 'remote-signing'
} as const;
export type CreateTableOperationXIcebergAccessDelegationEnum = typeof CreateTableOperationXIcebergAccessDelegationEnum[keyof typeof CreateTableOperationXIcebergAccessDelegationEnum];
/**
 * @export
 */
export const LoadTableXIcebergAccessDelegationEnum = {
    VendedCredentials: 'vended-credentials',
    RemoteSigning: 'remote-signing'
} as const;
export type LoadTableXIcebergAccessDelegationEnum = typeof LoadTableXIcebergAccessDelegationEnum[keyof typeof LoadTableXIcebergAccessDelegationEnum];
/**
 * @export
 */
export const LoadTableSnapshotsEnum = {
    All: 'all',
    Refs: 'refs'
} as const;
export type LoadTableSnapshotsEnum = typeof LoadTableSnapshotsEnum[keyof typeof LoadTableSnapshotsEnum];
