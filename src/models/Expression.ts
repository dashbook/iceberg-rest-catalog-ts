/* tslint:disable */
/* eslint-disable */
/**
 * Apache Iceberg REST Catalog API
 * Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AndOrExpression } from './AndOrExpression';
import {
    instanceOfAndOrExpression,
    AndOrExpressionFromJSON,
    AndOrExpressionFromJSONTyped,
    AndOrExpressionToJSON,
} from './AndOrExpression';
import type { FalseExpression } from './FalseExpression';
import {
    instanceOfFalseExpression,
    FalseExpressionFromJSON,
    FalseExpressionFromJSONTyped,
    FalseExpressionToJSON,
} from './FalseExpression';
import type { LiteralExpression } from './LiteralExpression';
import {
    instanceOfLiteralExpression,
    LiteralExpressionFromJSON,
    LiteralExpressionFromJSONTyped,
    LiteralExpressionToJSON,
} from './LiteralExpression';
import type { NotExpression } from './NotExpression';
import {
    instanceOfNotExpression,
    NotExpressionFromJSON,
    NotExpressionFromJSONTyped,
    NotExpressionToJSON,
} from './NotExpression';
import type { SetExpression } from './SetExpression';
import {
    instanceOfSetExpression,
    SetExpressionFromJSON,
    SetExpressionFromJSONTyped,
    SetExpressionToJSON,
} from './SetExpression';
import type { TrueExpression } from './TrueExpression';
import {
    instanceOfTrueExpression,
    TrueExpressionFromJSON,
    TrueExpressionFromJSONTyped,
    TrueExpressionToJSON,
} from './TrueExpression';
import type { UnaryExpression } from './UnaryExpression';
import {
    instanceOfUnaryExpression,
    UnaryExpressionFromJSON,
    UnaryExpressionFromJSONTyped,
    UnaryExpressionToJSON,
} from './UnaryExpression';

/**
 * @type Expression
 * 
 * @export
 */
export type Expression = AndOrExpression | FalseExpression | LiteralExpression | NotExpression | SetExpression | TrueExpression | UnaryExpression;

export function ExpressionFromJSON(json: any): Expression {
    return ExpressionFromJSONTyped(json, false);
}

export function ExpressionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Expression {
    if (json == null) {
        return json;
    }
    if (instanceOfAndOrExpression(json)) {
        return AndOrExpressionFromJSONTyped(json, true);
    }
    if (instanceOfFalseExpression(json)) {
        return FalseExpressionFromJSONTyped(json, true);
    }
    if (instanceOfLiteralExpression(json)) {
        return LiteralExpressionFromJSONTyped(json, true);
    }
    if (instanceOfNotExpression(json)) {
        return NotExpressionFromJSONTyped(json, true);
    }
    if (instanceOfSetExpression(json)) {
        return SetExpressionFromJSONTyped(json, true);
    }
    if (instanceOfTrueExpression(json)) {
        return TrueExpressionFromJSONTyped(json, true);
    }
    if (instanceOfUnaryExpression(json)) {
        return UnaryExpressionFromJSONTyped(json, true);
    }

    return {} as any;
}

export function ExpressionToJSON(json: any): any {
    return ExpressionToJSONTyped(json, false);
}

export function ExpressionToJSONTyped(value?: Expression | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    if (instanceOfAndOrExpression(value)) {
        return AndOrExpressionToJSON(value as AndOrExpression);
    }
    if (instanceOfFalseExpression(value)) {
        return FalseExpressionToJSON(value as FalseExpression);
    }
    if (instanceOfLiteralExpression(value)) {
        return LiteralExpressionToJSON(value as LiteralExpression);
    }
    if (instanceOfNotExpression(value)) {
        return NotExpressionToJSON(value as NotExpression);
    }
    if (instanceOfSetExpression(value)) {
        return SetExpressionToJSON(value as SetExpression);
    }
    if (instanceOfTrueExpression(value)) {
        return TrueExpressionToJSON(value as TrueExpression);
    }
    if (instanceOfUnaryExpression(value)) {
        return UnaryExpressionToJSON(value as UnaryExpression);
    }

    return {};
}

